<header>
</header>
<html>
<head>
    <style>

        #cdiv {
            padding: 10px;
        }

            #cdiv th > div,
            #cdiv td:not(:first-child) > div {
                display: grid;
                grid-template-columns: 1fr 1fr;
                align-items: center;
                height: 100%;
                vertical-align: top;
            }

        td:has(div>div:only-child>span:only-child) {
            vertical-align: top;
        }

        #cdiv td > div > div:nth-child(2) {
            max-width: min-content;
        }

        #cdiv td div span {
            white-space: pre-wrap;
            overflow-wrap: break-word;
            width: 100%;
        }

        body > div {
            display: flex;
            flex-direction: column;
        }

        #glyph {
            display: flex;
            flex-direction: row;
        }

            #glyph > div {
                border: none !important;
                padding: 4px !important;
            }

        table {
            border-collapse: collapse;
        }

        td > div > div:has(>span:only-child) {
            align-self: start;
            max-width: 150px;
            text-align: left;
        }

        td {
            max-width: 150px;
            border: solid #404040 2px;
            text-align: center;
        }

        thead > tr > th:not(:first-child),
        tbody > tr:nth-child(odd) > td:first-child,
        tbody > tr:nth-child(even) > td:first-child {
            border: solid #202020 4px;
            background-color: #C0C0C0;
        }

        tbody > tr > td:last-child {
            border-right: solid #202020 4px;
            padding-right: 8px;
        }

        tbody > tr > td:nth-child(2) {
            padding-left: 8px;
        }

        tbody > tr:last-child > td {
            border-bottom: solid #202020 4px;
        }

        td,
        th {
            padding: 4px;
        }

        th {
            font-weight: normal;
        }

        tbody > tr:nth-child(odd) > td {
            background-color: #E8E8E8;
        }

        tbody > tr:nth-child(even) > td {
            background-color: #D0D0D0;
        }
    </style>
</head>
<body>
    <script>
        //////////////////////// Globals

        const row_sounds = [
            ['P', 'Pot'],
            ['B', 'Boy'],
            ['J', 'Jar'],
            ['V', 'Vat'],
            ['Sh', 'Shop'],
            ['N', 'Not'],
            ['T', 'Ton'],
            ['R', 'Run'],
            ['L', 'Lip'],
            ['Ch', 'Chat'],
            ['Z', 'Zip'],
            ['K', 'Kid'],
            ['D', 'Day'],
            ['F', 'Fig'],
            ['M', 'Man'],
            ['Th', 'That'],
        ];

        const col_sounds = [
            ['oy', 'plOY'],
            ['ay', 'stAY'],
            ['ie', 'tIE'],
            ['oe', 'fOE'],
            ['ah', 'blAH'],
            ['eh', 'mEH'],
            ['ee', 'fEEt'],
            ['oo', 'bOOt'],
        ];

        const punct = ['Punctuation', "STOP '.'", "Start Paren '('", "Start Quote '\"'", "Question '?'", "Excitement '!'", "End Paren ')'", "Quote '\"'", "Elipses '...'", 'Sarcasm', 'Rhetoric'];
        const punct_txt = 'Question/Excitement/Sarcasm/Rhetorical goes at the front';

        const strct = ['Structure', 'Verb', 'Subject', 'Object', 'Adjective', 'Adverb', 'Interjection', 'Conjunction', 'Question'];
        const strct_txt = '[Punctuation: Question/Excitement/Sarcastic/Rhetorical] <BR><BR>'
            + 'Interjection <BR><BR>'
            + 'Verb(Adverb) <BR><BR>'
            + 'Subject(Subject - Adjective)...<BR><BR>'
            + '(Conjunction Subject Subject - Adjective)... <BR><BR>'
            + 'Object(Object - Adjective)...<BR><BR>'
            + '(Conjunction Object Object - Adjective)...<BR><BR>'
            + '[Punctuation: STOP/Elipses/Repeat of punctuation at start for emphasis]';

        const cat = ['Category', 'Plant', 'Animal', 'Color', 'Environment', 'Weather', 'Body of Water', 'Elevation', 'Temerature', 'Humidity', 'Magic Element'];
        const cat_txt = '';

        const pron = ['Pronoun', 'Ordinal Tag', 'Self', 'Other (you)', 'Possessive', 'Reflexive', 'Plural', 'Unknown', 'Neuter', 'Feminine', 'Masculine',];
        const pron_txt = 'The "Ordinal Tag" can be associated with any noun: Pronoun, Subject, or Object by prepending it, followed by a number (usually 1,2,3). '
            + 'Afterwards the Ordinal Tag and the number can replace the noun until the number is associated with another noun.<BR><BR>'
            + 'Singular is the default.<BR>Pronouns are created by combining modifiers in the order presented. '
            + 'For "We" where it is a masculine person, with other males and one female, would be: "SelfMaleOtherPluralMaleFemale". <BR><BR>'
            + 'Note that: "Self/Other/Possessive/Reflexive" are only included once.Gender is one of: Unknown, Neuter, Feminine, Masculine. '
            + 'Unkown is the default gender but may need to be explicitely included if it is needed to combine with other genders.<BR><BR>'
            + 'Other is only required after Self, by itself Other is the same as OtherPluralMalePluralFemale, '
            + 'and OtherPlural means more than one but genders are uncertain';

        const number_col = 2;
        const number = ['Number', '0',
            '1', '2', '3', '4', '5',
            '6', '12', '18', '24', '30',
            '*36', '*1,296', '*46,656', '*1,679,616', '*60,466,176',
        ];

        const number_digits = number.length - 2;
        const zero_lit = row_sounds[0][0] + col_sounds[number_col][0];
        const zero_rec = [0, 0];
        const zero_seq = [zero_rec];
        const inf_seq = [zero_rec, zero_rec];
        const n_inf_seq = [zero_rec, zero_rec, zero_rec];

        const number_txt = 'Numbers are formed by adding the included numbers, high to low. Note that 10 is 6+4 and 100 is 36*2+24+4<BR><BR>'
            + 'Numbers ' + row_sounds[0][0] + col_sounds[number_col][0] + ' (36) and above are marked with a * to designate they are used as multipliers '
            + '(they must have a ' + row_sounds[1][0] + col_sounds[number_col][0] + '(1) after to represent their value) < BR > <BR>'
            + 'This means that the highest possible number is 2,176,782,335 -- Numbers above this are limitless'
            + zero_lit + ' means "Not". By itself, it means 0. '
            + zero_lit + zero_lit + ' means limitless (above 2,176,782,335) and Pie before any other number means negative. '
            + zero_lit + zero_lit + zero_lit + ' means below -2,176,782,335)'

        const skip = [[], ''];

        const ctext = [
            [punct, punct_txt],
            [strct, strct_txt],
            [number, number_txt],
            [cat, cat_txt],
            [pron, pron_txt],
            skip,
            skip,
            skip,
        ];

        var inf_val = getnum(number_digits) * 36;
        var n_inf_val = -1 * inf_val;

        const IMG_W = 40;
        const IMG_H = 40;

        const PAD_SZ = (IMG_W + IMG_H) / 10;

        const SB = [[100, 80], [100, 50], [100, 25], [100, 10], [40, 80], [40, 50], [40, 25], [40, 10]];

        // Globals set after document.ready()

        var number = null;
        var glyph = null;
        var math = null;
        var lit = null;
        var Xcore = null;
        var Xr8 = null;
        var Xr4 = null;
        var Xr2 = null;
        var Xr1 = null;
        var Xc4 = null;
        var Xc2 = null;
        var Xc1 = null;

        //////////////////////////////// Functions

        function get_ctext(row, col, is_data = true) {
            if (col >= ctext.length) {
                return '';
            }
            if (is_data) {
                var number_col = ctext[col][0];
                if (row >= number_col.length) {
                    return '';
                }
                return number_col[row]
            }
            return ctext[col][1];
        }

        function num_sound(row) {
            var ret = row_sounds[row][0] + col_sounds[number_col][0];
            return ret;
        }

        //Color Hue, Sat/Brightness -- 3 letters (Category:Color)(Hue)(B/S)
        // Hue: L1 of 127 is greyscale:
        //   Hue = 0
        //   Sat = 0
        //   Brightness = L2*100/127
        // otherwise:
        //   Hue = L1*360/126
        //   Sat = L2:Vowel*100/7
        //   Brightness = L2:Consonent*100/15
        function color_div(h, s, b) {
            var div = mk_div();
            div.style.backgroundColor = "hsl(" + h + "," + s + "%," + b + "%)";
            return div;
        }
        function create_color(row, col) {
            var H = 0;
            var S = 0;
            var B = 0;
            if (row == 0) { // Greyscale
                B = col * 100 / 7;
            } else {
                H = row * 360 / 16;
                S = SB[col][0];
                B = SB[col][1];
            }
            return color_div(H, S, B);
        }

        function mk_layer(nm) {
            var img = mk_img(nm);
            img.style.position = 'absolute';
            img.style.left = 0;
            img.style.top = 0;
            img.style.width = IMG_W + 'px';
            img.style.height = IMG_H + 'px';
            return img;
        }

        function mk_overlay(hdr, r8, r4, r2, r1, c4, c2, c1) {
            var img = [];
            if (!hdr) {
                img.push(Xcore.cloneNode());
            }
            if (r8) {
                img.push(Xr8.cloneNode());
            }
            if (r4) {
                img.push(Xr4.cloneNode());
            }
            if (r2) {
                img.push(Xr2.cloneNode());
            }
            if (r1) {
                img.push(Xr1.cloneNode());
            }
            if (c4) {
                img.push(Xc4.cloneNode());
            }
            if (c2) {
                img.push(Xc2.cloneNode());
            }
            if (c1) {
                img.push(Xc1.cloneNode());
            }
            inner_div = mk_div(img);
            inner_div.style.minHeight = IMG_H + 'px';
            inner_div.style.minWidth = IMG_W + 'px';
            inner_div.style.maxHeight = IMG_H + 'px';
            inner_div.style.maxWidth = IMG_W + 'px';

            mid_div = mk_div([inner_div]);
            mid_div.style.position = 'relative';
            mid_div.style.minHeight = IMG_H + 'px';
            mid_div.style.minWidth = IMG_W + 'px';
            mid_div.style.maxHeight = IMG_H + 'px';
            mid_div.style.maxWidth = IMG_W + 'px';
            outer_div = mk_div([mid_div]);

            outer_div.style.padding = PAD_SZ + 'px';
            outer_div.style.minHeight = IMG_H + 'px';
            outer_div.style.minWidth = IMG_W + 'px';
            outer_div.style.maxHeight = IMG_H + 'px';
            outer_div.style.maxWidth = IMG_W + 'px';
            outer_div.style.border = '1px solid #808080';

            return outer_div;
        }

        document.addEventListener('DOMContentLoaded', function () {
            number = document.getElementById('number');
            glyph = document.getElementById('glyph');
            math = document.getElementById('math');
            lit = document.getElementById('lit');
            Xcore = mk_layer('ZBase.png');
            Xr8 = mk_layer('ZC8.png');
            Xr4 = mk_layer('ZC4.png');
            Xr2 = mk_layer('ZC2.png');
            Xr1 = mk_layer('ZC1.png');
            Xc4 = mk_layer('ZV4.png');
            Xc2 = mk_layer('ZV2.png');
            Xc1 = mk_layer('ZV1.png');

            var prepositions = ['Preposition', 'over (under)', 'in (out)', 'inside (outside)', 'front (back)', 'left (right)', 'up (down)'];
            var questions = ['Question', 'who', 'where', 'when', 'how', 'why	is true?', 'is known?'];
            var conj = ['Conjunction', 'and', 'or', 'not (but)', 'because', 'then', 'iff'];
            var interjection = ['Interjection', 'Happy', 'Suprise', 'Pain', 'Frustration', 'Sad', 'Love', 'Hate'];

            var cbody = document.getElementById("cbody");
            var chead = document.getElementById("chead");
            var blank = wrap('');
            var bool = [false, true];
            var all = [];
            var row = 0;
            var header = false;
            var hdr_images = [blank];
            var ftr_images = [wrap('Comments:')];
            bool.forEach(r8 => {
                bool.forEach(r4 => {
                    bool.forEach(r2 => {
                        bool.forEach(r1 => {
                            var col = 0;
                            var lping = mk_overlay(true, r8, r4, r2, r1, false, false, false);
                            var images = [
                                mk_div([
                                    mk_div([
                                        lping, bold(row_sounds[row][0]), wrap(' '), italic(row_sounds[row][1])
                                    ])
                                ])
                            ];
                            bool.forEach(c4 => {
                                bool.forEach(c2 => {
                                    bool.forEach(c1 => {
                                        var rping = mk_overlay(false, r8, r4, r2, r1, c4, c2, c1);
                                        if (!header) {
                                            var hdr = mk_div([
                                                mk_overlay(true, false, false, false, false, c4, c2, c1), bold(col_sounds[col][0]), wrap(' '), italic(col_sounds[col][1])
                                            ]);
                                            hdr_images.push(mk_div([
                                                hdr, mk_div([
                                                    bold(get_ctext(0, col))
                                                ])
                                            ]));
                                            var ftr = mk_div([
                                                wrap(get_ctext(0, col, false))
                                            ]);
                                            ftr_images.push(mk_div([ftr]));
                                        }
                                        var div = mk_div([
                                            rping, italic(row_sounds[row][0] + col_sounds[col][0])
                                        ]);
                                        images.push(mk_div([
                                            div,
                                            mk_div([
                                                bold(get_ctext(row + 1, col))
                                            ])
                                        ]));
                                        col++;
                                    }); // c1
                                }); // c2
                            }); // c4
                            if (!header) {
                                header = true;
                                chead.appendChild(mk_row('th', hdr_images));
                            }
                            cbody.appendChild(mk_row('td', images));
                            row++;
                        }); // r1
                    }); // r2
                }); // r4
            }); // r8
            cbody.appendChild(mk_row('td', ftr_images));
        });

        function mk_img(img) {
            var elem = document.createElement("img");
            elem.src = img;
            return elem;
        }

        function wrap(text) {
            var span = document.createElement("span");
            span.innerHTML = text;
            return span;
        }

        function br() {
            return wrap('<br>');
        }

        function attr(x, text) {
            return wrap('<' + x + '>' + text + '</' + x + '>');
        }

        function italic(text) {
            return attr('i', text);
        }

        function bold(text) {
            return attr('b', text);
        }

        function mk_span(items) {
            return mk_container("span", items);
        }

        function mk_div(items) {
            return mk_container("div", items);
        }

        function mk_container(container, items) {
            var box = document.createElement(container);
            items.forEach(i => {
                box.appendChild(i);
            });
            return box;
        }

        function mk_row(tp, item) {
            var row = document.createElement('tr');
            item.forEach(i => {
                var cell = document.createElement(tp);
                cell.append(i);
                row.append(cell);
            });
            return row;
        }

        function getnum_txt(row) {
            var txt = get_ctext(row + 1, number_col, true);
            return txt;
        }

        function getnum(row) {
            var num = getnum_txt(row);
            var numval = Number(num.replace(/[*,]/g, ''));
            return numval;
        }

        function ismult(row) {
            var num = getnum_txt(row);
            return num.includes('*');
        }

        function mk_numglyph(row) {
            return mk_overlay(false, row & 8, row & 4, row & 2, row & 1, number_col & 4, number_col & 2, number_col & 1);
        }

        function convertnum(val, ret) {
            if (val == 0) {
                return ret;
            }

            for (var c = number_digits; c > 0; --c) {
                var n = getnum(c);
                var x = n;
                var p = 0;
                var skip = false;
                if (ismult(c)) {
                    p = Math.floor(val / n);
                    x = n * p;
                    if (p == 0) {
                        skip = true;
                    }
                } else if (n > val) {
                    skip = true;
                }
                if (skip) {
                    continue;
                }
                var rec = [p, c];
                ret.push(rec);
                val -= x;
            }

            return ret;
        }

        function calc() {
            const val_raw = number.value;
            const val_strip = val_raw.replace(/[,*]/g, ''); // remove all ,
            const val = Number(val_strip); // convert to number

            glyph.innerHTML = '';
            math.innerHTML = '';
            lit.innerHTML = '';

            if (isNaN(val)) {
                lit.innerText = 'Please Enter a Valid Number';
                return;
            }

            var lsep = '';
            var mtext = '[' + val.toString(6) + '] ';
            var ltext = '';
            var alt = '';
            var msep = '';
            var seq = null;

            if (val <= 0) {
                seq = zero_seq;
                if (val <= n_inf_val) {
                    seq = n_inf_seq;
                    alt = 'Too Low';
                } else if (val == 0) {
                    alt = 'Zero';
                } else {
                    seq = convertnum(-1 * val, seq); // val is negative
                    msep = '-';
                }
            } else if (val >= inf_val) {
                seq = inf_seq;
                alt = 'Too High';
            } else {
                seq = convertnum(val, []);
            }

            glyph.innerHTML = '';
            var msep_after = ' + ';
            var lsep_after = '';
            for (var x = 0; x < seq.length; x++) {
                var rec = seq[x];
                var prow = rec[0];
                var nrow = rec[1];
                var nval = getnum(nrow);
                var prowA = 0;
                var prowB = prow;
                var pvalA = 0;
                var pvalB = 0;

                if (prow > 0) { // using a multiplier
                    if (prow > 6) { // it's on the second hand
                        prowA = 5 + Math.floor(prow / 6);
                        pvalA = getnum(prowA);
                        prowB = prow - pvalA;
                    }
                    pvalB = getnum(prowB);
                }

                var nlit = num_sound(nrow);
                var nobj = mk_numglyph(nrow);
                mtext += msep + nval;
                ltext += lsep + nlit;

                glyph.appendChild(nobj);
                if (pvalA > 0) {
                    var plitA = num_sound(prowA);
                    var pobjA = mk_numglyph(prowA);
                    if (pvalB > 0) {
                        var plitB = num_sound(prowB);
                        var pobjB = mk_numglyph(prowB);
                        mtext += ' * (' + pvalA + msep_after + pvalB + ')';
                        ltext += lsep_after + plitA + lsep_after + plitB;

                        glyph.appendChild(pobjA);
                        glyph.appendChild(pobjB);
                    } else {
                        mtext += ' * ' + pvalA;
                        ltext += lsep_after + plitA;

                        glyph.appendChild(pobjA);
                    }
                } else if (pvalB > 0) {
                    var plitB = num_sound(prowB);
                    var pobjB = mk_numglyph(prowB);
                    mtext += ' * ' + pvalB;
                    ltext += lsep_after + plitB;

                    glyph.appendChild(pobjB);
                }

                if (msep == '-') {
                    mtext += msep;
                    msep = '';
                } else {
                    msep = msep_after;
                }
              
                lsep = lsep_after;
            }
            if (alt == '') {
                math.innerText = mtext;
            } else {
                math.innerText = alt;
            }
            lit.innerText = ltext;
        }

    </script>
    <div>
        <div>
            <label for="number">Enter a Number:</label>
            <input type="text" id="number" name="number"><br><br>
            <button type="button" onclick="calc();">Calculate</button>
            <div id='math'></div>
            <div id='glyph'></div>
            <div id='lit'></div>
        </div>
        <div id='cdiv'>
            <table id='ctable'>
                <thead id='chead'>
                </thead>
                <tbody id='cbody'>
                </tbody>
            </table>
        </div>
    </div>
</body>
</html>                            